/* viewIssue.js 
 */
var dbAccess = require('dbAccess'), 
	querystring = require('querystring'),
	reputation = require('reputation'), 
	tags = require('tags'),
	url = require('url'),
	users = require('users'),
	emailUtil = require('emailUtil');

var g_UserId = -1;
var g_UserVote; 
var thisIssueId;

var ViewIssue = exports.ViewIssue = function() {};

/**
 * Send the HTML page to the client
 * @param response Response object to send the data
 * @param issue Issue to display
 */
function displayPage(response, issue) {

	return function(error, users) {
		thisIssueId = issue['id'];
		
		// query view count and update it for current issue
		var sqlViewCount =  "SELECT views FROM issues WHERE id = " + thisIssueId;
		dbAccess.runQuery(sqlViewCount, function(error, views) {
			if (error) throw error;
		
			var viewcount = views[0]['views'];
			if (!viewcount)
				viewcount = 1;
			else
				viewcount += 1;
				
			dbAccess.update('issues', { values:[ 'views="' + viewcount + '"' ], 
			conditions:['id="' + thisIssueId + '"'] }, function(error) { 
				if (error) throw error;
			}); 
		});
		
		var user = users[0];

		g_UserVote = -1; //Assume that the user hasn't voted initially

		//Check if the user has already voted
		var sqlAlreadyVoted = "SELECT * FROM votes WHERE user_id = " + g_UserId + " AND issue_id = " + issue['id'];

		dbAccess.runQuery(sqlAlreadyVoted, function(error, rows_vote) {
			if (error) throw error;
			if (rows_vote.length == 1) {
				g_UserVote = rows_vote[0]['vote'];
			}

			var sqlQuery = "SELECT id,content,user_id,created FROM comments WHERE issue_id=" + thisIssueId + " ORDER BY created ASC";
			dbAccess.runQuery(sqlQuery, function (error, rows) {
				if (error) throw error;

				var sqlQuery2 = "SELECT id,name FROM users";
				dbAccess.runQuery(sqlQuery2, function (error, rows2) {
					if (error) throw error;

					contentArray = []; 

					if (rows.length > 0) {
						var name = "";
						var buttonType = "";
						for (var i = 0; i <= rows.length - 1; i++) {
							for (var j = 0; j <= rows2.length - 1; j++) {
								if (rows2[j].id == rows[i].user_id) {
									name = rows2[j].name;
									break;
								}
							}
							if(rows[i].user_id == g_UserId)
								buttonType = "button";
							else
								buttonType = "hidden";
							var obj = {
								iCommentCreatorId : rows[i].user_id,
								iCommentCreatorName : name,
								iCommentCreatedTime : dateFormat(rows[i].created, "dddd, mmmm dS, yyyy, h:MM:ss TT"),
								iCommentContent : rows[i].content,
								iButtonType : buttonType,
								iCommentId : rows[i].id,
								iIssueId : thisIssueId
							};
							contentArray.push(obj);
						}
					}

					checkForNextAndPrevIssues(thisIssueId, function(issueLinks){
						getStats(thisIssueId, function(issueStats) {
							getFollow(g_UserId, thisIssueId, function(follows) {
							  
								tags.getTagsList(issue.id, function(tagList) {
									var tags = [];
									for (i = 0; i < tagList.length; i++) {
										var t = { name : tagList[i] };
										tags.push(t);
									}
									
								var isUserLoggedIn = null;
								if (g_UserId > -1) 
									isUserLoggedIn = true;

								variables = {
									found: true,
									quickTaskButtons_partial: 'views/layouts/partials/quickTaskButtons_partial.html',
									quickTaskButtons: {id: issue.id},
									title: issue.title,
									created: dateFormat(issue.created, "dddd, mmmm dS, yyyy, h:MM:ss TT"), 
									user: user,
									user_id: user.id,
									user_name: user.name,
									status: issue.status,
									location: issue.location,
									description: issue.description,
									link: issue.link,
									file_name: issue.fileLocation,
									file_link: 'uploads/'+issue.id+'/'+issue.fileLocation,
									issue_id: issue.id,
									userHasVoted: g_UserVote != -1,
									comments: contentArray,
									// vars for issue stats
									lastModified: dateFormat(issue.lastModified, "dddd, mmmm dS, yyyy, h:MM:ss TT"),
									numComments: issueStats[0],
									numFollowers: issueStats[1],
									promotes: issueStats[2],
									numViews: issueStats[3],
									tags: tags,
									following: follows,
									signedIn: isUserLoggedIn,
								}
								// if next or prev issues are defined, then get their title and issue ids
								if ( issueLinks[0])
								{
									variables.prevIssue = issueLinks[0];
									variables.prevIssueId = thisIssueId-1;
								}
								if ( issueLinks[1])
								{
									variables.nextIssue= issueLinks[1];
									variables.nextIssueId = thisIssueId+1;
								}
									
								response.render('views/viewIssue.html', variables);
								});
							});
						}); // end of queries of issue stats
					}); // end query for issue links
				});
			});
		});
   };
}

/**
* Queries the DB for issue statistics such as number of comments, followers, and views
* @param thisIssueId Current issue
*/
function getStats(thisIssueId, callback) {
	// find number of followers
	var queryFollowers= "SELECT count (*) FROM follows WHERE issue_id = " + thisIssueId;
	// find number of comments
	var queryComments= "SELECT count (*) FROM comments  WHERE issue_id = " + thisIssueId;
	// find view count and promotes
	var queryViews= "SELECT views, promotes FROM issues WHERE id = " + thisIssueId;
	
	 dbAccess.runQuery(queryFollowers, function (error, followers) {
		if (error) throw error;
			dbAccess.runQuery(queryComments, function (error, comments) {
				if (error) throw error;
					dbAccess.runQuery(queryViews, function (error, views) {
						if (error) throw error;
						
						var issueStats = [0,0,0,0];
	
						issueStats[0] = comments[0]['count (*)'];
						issueStats[1] = followers[0]['count (*)'];
						issueStats[2] = views[0]['promotes'];
						issueStats[3] = views[0]['views'];
						
						if (callback instanceof Function) { callback(issueStats); } 
					});
			});
		});		
}


function checkForNextAndPrevIssues(thisIssueId, callback) {
	var next = thisIssueId+1;
	var prev = thisIssueId-1;
	
	// check if next issue exists
	var queryNextIssue= "SELECT title FROM issues WHERE id = " + next;
	// check if prev issue exists
	var queryPrevIssue= "SELECT title FROM issues WHERE id = " + prev;
	
	dbAccess.runQuery(queryNextIssue, function (error, nextIssue) {
		if (error) throw error;
			dbAccess.runQuery(queryPrevIssue, function (error, prevIssue) {
				if (error) throw error;
		
				var issueLinks = [undefined,undefined];
				if (prevIssue[0])
					issueLinks[0] = prevIssue[0]['title'];
				if (nextIssue[0])
					issueLinks[1] = nextIssue[0]['title'];
				
				if (callback instanceof Function) { callback(issueLinks); } 
			});
	});
}

function getFollow(g_UserId, thisIssueID, callback) {
	var isfollowing;
	var findFollowing = "SELECT * FROM (SELECT * FROM follows WHERE issue_id=" + thisIssueID + ") WHERE user_id=" + g_UserId;
	//console.log(findFollowing);
	dbAccess.runQuery(findFollowing, function(error, follows){
		if(error) throw error;
		if(callback instanceof Function) { callback(follows); }
	});
}

ViewIssue.addcomments = function (req,res) {
	var requestString = "";

	if (g_UserId == -1) {
		res.statusCode = 302;
		res.setHeader('Location', '/signin');
		res.end();
	}
	else {
		req.on('data', function (chunk) {
			requestString = requestString + chunk;
		});
		req.on('end', function() {
			var decodedBody = querystring.parse(requestString);
			if(decodedBody.comments.trim() != ""){
				var sqlQuery = "INSERT INTO comments (id,user_id,issue_id,content) VALUES ("
				+ null + ",'"
				+ g_UserId + "','"
				+ thisIssueId + "','"
				+ decodedBody.comments
				+ "')";
				dbAccess.runQuery(sqlQuery, function (error, rows) {
					if(error) throw error;
					res.statusCode = 302;
					res.setHeader('Location', '/viewIssue?id=' + thisIssueId);
					res.end();
				});
				
				// sending email notification to the issue's owner that a new comment has been posted
				dbAccess.find('users', { conditions:['id="' + g_UserId + '"']}, function(error, this_user){
					if (error) throw error;
					if (this_user) {
						dbAccess.find('issues', { conditions:['id="' + thisIssueId + '"']}, function(error, issue_owner){
							if (error) throw error;
							if (issue_owner) {					
								dbAccess.find('users', { conditions:['id="' + issue_owner[0].user_id + '"']}, function(error, owner){
									if (error) throw error;
									if (owner) {
										console.log('sending notification to user: ' + issue_owner[0].user_id + ' with email: ' + owner[0].email);
										var subject = '[CivicConnect] ' + this_user[0].name + ' has commented on your issue';
										var body =  'Issue: ' + issue_owner[0].title + '\n\n' +
													this_user[0].name + ' says, "' +
													decodedBody.comments + '"\n';										

										emailUtil.sendPlainTextEmailToUserId(issue_owner[0].user_id, subject, body, function(error, success) {
											if (error)
												console.log('Error sending notification email to ' + owner[0].email);
											else 
												console.log('Notification email sent successfully to ' + owner[0].name + ' ' + owner[0].email);
										});							
									}
								});		
							}					
						});
					}
				});
				
				reputation.updateOnAddComment(thisIssueId, g_UserId, decodedBody.comments); 
			}
			else{
				res.statusCode = 302;
				res.setHeader('Location', '/viewIssue?id=' + thisIssueId);
				res.end();
			}
		});
	}
}

/**
* Retrieve the user corresponding to the issue
* @param response Response object to send the data
*/
function findIssueCreator(response, issueId) {
	return function(error, rows) {
		if (error) throw error;

		var issue = rows[0];

		if (issue == undefined) {
			variables = { found: false, issue_id: issueId }
			response.render('views/viewIssue.html', variables);
		}
		else
			dbAccess.runQuery('SELECT * FROM users WHERE id=' + issue['user_id'], displayPage(response, issue));
	};
}

var dateFormat = function () {
	var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
		timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
		timezoneClip = /[^-+\dA-Z]/g,
		pad = function (val, len) {
			val = String(val);
			len = len || 2;
			while (val.length < len) val = "0" + val;
			return val;
		};

	// Regexes and supporting functions are cached through closure
	return function (date, mask, utc) {
		var dF = dateFormat;

		// You can't provide utc if you skip other args (use the "UTC:" mask prefix)
		if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
			mask = date;
			date = undefined;
		}

		// Passing date through Date applies Date.parse, if necessary
		date = date ? new Date(date) : new Date;
		if (isNaN(date)) throw SyntaxError("invalid date");

		mask = String(dF.masks[mask] || mask || dF.masks["default"]);

		// Allow setting the utc argument via the mask
		if (mask.slice(0, 4) == "UTC:") {
			mask = mask.slice(4);
			utc = true;
		}

		var	_ = utc ? "getUTC" : "get",
			d = date[_ + "Date"](),
			D = date[_ + "Day"](),
			m = date[_ + "Month"](),
			y = date[_ + "FullYear"](),
			H = date[_ + "Hours"](),
			M = date[_ + "Minutes"](),
			s = date[_ + "Seconds"](),
			L = date[_ + "Milliseconds"](),
			o = utc ? 0 : date.getTimezoneOffset(),
			flags = {
				d:    d,
				dd:   pad(d),
				ddd:  dF.i18n.dayNames[D],
				dddd: dF.i18n.dayNames[D + 7],
				m:    m + 1,
				mm:   pad(m + 1),
				mmm:  dF.i18n.monthNames[m],
				mmmm: dF.i18n.monthNames[m + 12],
				yy:   String(y).slice(2),
				yyyy: y,
				h:    H % 12 || 12,
				hh:   pad(H % 12 || 12),
				H:    H,
				HH:   pad(H),
				M:    M,
				MM:   pad(M),
				s:    s,
				ss:   pad(s),
				l:    pad(L, 3),
				L:    pad(L > 99 ? Math.round(L / 10) : L),
				t:    H < 12 ? "a"  : "p",
				tt:   H < 12 ? "am" : "pm",
				T:    H < 12 ? "A"  : "P",
				TT:   H < 12 ? "AM" : "PM",
				Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
				o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
				S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
			};

		return mask.replace(token, function ($0) {
			return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
		});
	};
}();

// Some common format strings
dateFormat.masks = {
	"default":      "ddd mmm dd yyyy HH:MM:ss",
	shortDate:      "m/d/yy",
	mediumDate:     "mmm d, yyyy",
	longDate:       "mmmm d, yyyy",
	fullDate:       "dddd, mmmm d, yyyy",
	shortTime:      "h:MM TT",
	mediumTime:     "h:MM:ss TT",
	longTime:       "h:MM:ss TT Z",
	isoDate:        "yyyy-mm-dd",
	isoTime:        "HH:MM:ss",
	isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
	isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
dateFormat.i18n = {
	dayNames: [
		"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
		"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
	],
	monthNames: [
		"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
		"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
	]
};

/**
* Main function of the module
* @param request Incoming request
* @param response Response object to send the data
*/
ViewIssue.display = function(request, response) {
	var parsedURL = url.parse(request.url, true);
	
	// Reset the logged-in user id
	g_UserId = -1;

	// Check to see if we have an issue id from the url
	if (!parsedURL.query.id) {
		// If not, we'll render the page now
		var variables = {
			found: false,
			issue_id: 'null'
		};
		response.render('views/viewIssue.html', variables);
	}
	else {
		// Otherwise, we can proceed normally
		var issueId = parsedURL.query.id;
		request.getUser(function(error, user) {
			if (error) {
				util.log('Error getting current user in viewIssue.display. ' + error);
				var variables = {
					error: 'Internal Server Error: Error retrieving current user'
				};
				response.render('views/viewIssue.html', variables);
			}
			if (user) g_UserId = user.id;
			var sqlQuery = "SELECT * FROM issues WHERE id='" + issueId + "';";
			dbAccess.runQuery(sqlQuery, findIssueCreator(response, issueId));
		});
	}
};
