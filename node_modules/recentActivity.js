/* recentActivity.js 
 * Aggregates recent events (issue created, comments added, comments/issues voted) 
 * based on a person's interests in issues, topics and locations
 */ 
 
var dbAccess = require('dbAccess'),
	step = require('step'),
	users = require('users'), 
	util = require('util');
	
var MAX_RESULTS = 100; 

/* getLatestIssues 
 * Returns the latest issues. A maximum number of issues to return can be specified 
 *
 * @param numIssues The maximum number of issues to return 
 * @param callback A callback with (error, results) 
 */ 
function getLatestIssues(numIssues, callback) { 
	var maxIssues = (numIssues < 0) ? -1 : numIssues; 
	dbAccess.find('issues', { orderby: 'created DESC', limit: maxIssues }, function(error, results) {
		callback(error, results); 
	});
}

/* getLatestIssuesByUser
 * Returns the latest issues by a specified user. A maximum number of issues to return can be specified 
 *
 * @param userId The user id of the author of issues to return 
 * @param numIssues The maximum number of issues to return 
 * @param callback A callback with (error, results) 
 */ 
function getLatestIssuesByUsers(userIds, numIssues, callback) {
	if (userIds.length <= 0) { 
		return callback(null, []); 
	}
	var userIdList = ''; 
	for (var i = 0; i < userIds.length; i++) { 
		userIdList += 'user_id="' + userIds[i] + '"'; 
		if (i != userIds.length - 1) {
			userIdList += ' OR '; 
		}		
	}
	
	var maxIssues = (numIssues < 0) ? -1 : numIssues; 
	dbAccess.find('issues', { conditions: [ userIdList ], 
		orderby: 'created DESC', limit: maxIssues }, function(error, results) {
			callback(error, results); 
	});
}

/* getLatestComments  
 * Returns the latest comments. A maximum number of comments to return can be specified. 
 *
 * @param numComments The maximum number of comments to return 
 * @param callback A callback with (error, results) 
 */
function getLatestComments(numComments, callback) { 
	var maxComments = (numComments < 0) ? -1 : numComments; 
	dbAccess.find('comments', { orderby: 'created DESC', limit: numComments }, function(error, results) {
		callback(error, results); 
	});
}

/* getLatestCommentsByUser 
 * Returns the latest comments by a specified user. A maximum number of comments to return can be specified. 
 *
 * @param userIds The user id of the author of comments to return 
 * @param numComments The maximum number of comments to return 
 * @param callback A callback with (error, results) 
 */
function getLatestCommentsByUsers(userIds, numComments, callback) {
	if (userIds.length <= 0) { 
		return callback(null, []); 
	}
	var userIdList = ''; 
	for (var i = 0; i < userIds.length; i++) { 
		userIdList += 'user_id="' + userIds[i] + '"'; 
		if (i != userIds.length - 1) {
			userIdList += ' OR '; 
		}		
	}
	var maxComments = (numComments < 0) ? -1 : numComments; 
	dbAccess.find('comments', { conditions: [ userIdList ], 
		orderby: 'created DESC', limit: numComments }, function(error, results) {
			callback(error, results); 
	});
}

/* getInterests 
 * Gets the interests for a user 
 *
 * @param userId The id of the user 
 * @param callback A callback with (error, results) 
 */ 
function getInterests(userId, callback) { 
	dbAccess.find('interests', { conditions: ['user_id="' + userId + '"'] }, function(error, results) { 
		callback(error, results); 
	});
}

/* getUserLocation
 * Gets the location/neighborhood of a user 
 * 
 * @param userId The id of the user 
 * @param callback A callback with (error, results) where results is the user's neighborhood 
 */ 
function getUserLocation(userId, callback) {
	dbAccess.find('users', { properties: [ 'neighborhood' ], conditions: ['id="' + userId + '"'] }, 
		function(error, results) { 
			callback(error, results); 
	});
}

/* getRecentActivityList 
 * Returns a list of recent activity (issues and comments) 
 * 
 * @param maxResults The maximum number of results to return 
 * @param callback A callback which returns an object with the following properties: 
 *      type : The type of results (e.g. 'issue' or 'comment') 
 *      contents : The result contents 
 */
exports.getRecentActivityList = function(maxResults, callback) {
	step(
		function loadData() {
			getLatestIssues(MAX_RESULTS, this.parallel());
			getLatestComments(MAX_RESULTS, this.parallel());
		},
		function handleCallback(err, issues, comments) {
			if (err) throw error;
			
			var all_results = []; 
			
			function dateComparator(a, b) {
				var a = new Date(a.contents.created), b = new Date(b.contents.created);
				return (b.getTime() - a.getTime());
			}
			
			for (i in issues) { 
				all_results.push({ 'type' : 'issue', 'contents' : issues[i] }); 
			}
			for (c in comments) {
				all_results.push({ 'type' : 'comment', 'contents' : comments[c] }); 
			}
			
			all_results.sort(dateComparator); 
			callback(null, all_results.slice(0, maxResults));
		}
	);
}

/* getUserRecentActivityList 
 * Returns a list of recent activity (e.g. issues and comments) for a user 
 * 
 * @param userId The id of the user 
 * @param maxResults The maximum number of results to return 
 * @param callback A callback which returns an object with the following properties: 
 *      type : The type of results (e.g. 'issue' or 'comment') 
 *      contents : The result contents 
 *      relevance : The relevance score 
 */ 
exports.getUserRecentActivityList = function(userId, maxResults, callback) {
	step(
		function loadData() {
			getInterests(userId, this.parallel());
			getLatestIssues(MAX_RESULTS, this.parallel());
			getLatestComments(MAX_RESULTS, this.parallel());
			getUserLocation(userId, this.parallel()); 
		},
		function handleCallback(err, interests, issues, comments, neighborhood) {
			if (err) throw err;
			
			var all_results = []; 
			
			function dateComparator(a, b) {
				var a = new Date(a.contents.created), b = new Date(b.contents.created);
				return (b.getTime() - a.getTime());
			}
			
			function relevanceComparator(a, b) {
				return b.relevance - a.relevance; 
			}
			
			// Rank issues and comments 
			var foundInterests = (interests.length == 0) ? false: true; 
			for (i in issues) { 
				var issueRank = foundInterests ? rankIssueToInterests(issues[i], interests[0]) : 0;
				issueRank += rankIssueToLocation(issues[i], neighborhood); 
				all_results.push({ 'type' : 'issue', 'contents' : issues[i], 'relevance' : issueRank }); 
			}
			for (c in comments) {
				var commentRank = foundInterests ? rankCommentToInterests(comments[c], interests[0]) : 0; 
				commentRank += rankCommentToLocation(comments[c], neighborhood); 
				all_results.push({ 'type' : 'comment', 'contents' : comments[c], 'relevance' : commentRank }); 
			}
			
			// Sort results 
			if (foundInterests) {
				all_results.sort(relevanceComparator); 
			}
			else { 
				all_results.sort(dateComparator); 
			}
			all_results = all_results.slice(0, maxResults); 
			callback(null, all_results);
		}
	);
}

/* getFollowedUsersFeed 
 * Returns a list of activity from followed users by a given user 
 * 
 * @param userId The id of the user 
 * @param maxResults The maximum number of results to return 
 * @param callback A callback which returns an object with the following properties: 
 *      type : The type of results (e.g. 'issue' or 'comment') 
 *      contents : The result contents 
 */ 
exports.getFollowedUsersFeed = function(userId, maxResults, callback) { 
	users.getFollowedUsers(userId, function(error, results) {
		if (error) return callback(error, results); 
		step(
			function loadData() { 
				getLatestIssuesByUsers(results, MAX_RESULTS, this.parallel());
				getLatestCommentsByUsers(results, MAX_RESULTS, this.parallel());
			}, 
			function handleCallback(err, issues, comments) { 
				if (err) throw err; 
				
				var all_results = []; 
			
				function dateComparator(a, b) {
					var a = new Date(a.contents.created), b = new Date(b.contents.created);
					return (b.getTime() - a.getTime());
				}
				
				for (i in issues) { 
					all_results.push({ 'type' : 'issue', 'contents' : issues[i] }); 
				}
				for (c in comments) {
					all_results.push({ 'type' : 'comment', 'contents' : comments[c] }); 
				}
				
				all_results.sort(dateComparator); 
				all_results = all_results.slice(0, maxResults); 
				callback(null, all_results);
			}
		); 
	}); 
	
}

/* rankIssueToLocation
 * Determines the relevance of an issue based on the frequency of matches a user's location 
 * 
 * @param issue The issue 
 * @param neighborhood The user's neighborhood  
 */ 
function rankIssueToLocation(issue, neighborhood) {
	var rank = 0; 
	var neighborhoodParts = new String(neighborhood).split(/\s+/); 
	rank += countMatchesToInterests(issue.description, neighborhoodParts);
	rank += countMatchesToInterests(issue.title, neighborhoodParts);
	return rank; 
}

/* rankCommentToLocation 
 * Determines the relevance of a comment based on the frequency of matches a user's location 
 * 
 * @param issue The comment 
 * @param neighborhood The user's neighborhood  
 */ 
function rankCommentToLocation(comment, neighborhood) {
	var rank = 0; 
	var neighborhoodParts = new String(neighborhood).split(/\s+/); 
	rank += countMatchesToInterests(comment.content, neighborhoodParts);
	return rank; 
}

/* rankIssueToInterests 
 * Determines the relevance of an issue based on the frequency of matches to interests 
 * 
 * 'issue' The issue 
 * 'interests' The user interests 
 */ 
function rankIssueToInterests(issue, interests) {
	var rank = 0;
	var topics = createInterestList(interests.interest_topic); 	
	var locations = createInterestList(interests.interest_location); 	
	rank += countMatchesToInterests(issue.description, topics);
	rank += countMatchesToInterests(issue.title, topics);
	rank += countMatchesToInterests(issue.description, locations);
	rank += countMatchesToInterests(issue.title, locations);
	// TODO: Get issue tags once it is implemented 
	return rank; 
}

/* countMatchesToInterests 
 * Counts the number of matches 
 * 
 * 'text' The text to look for matches in 
 * 'interestList' A list of interests  
 */ 
function countMatchesToInterests(text, interestList) {
	var regex = buildRegExpQuery(interestList); 
	var matches = text.match(regex);
	return (matches == null) ? 0 : matches.length; 
}

/* rankCommentToInterests 
 * Determines the relevance of a comment based on the frequency of matches to interests 
 * 
 * 'comment' The comment
 * 'interests' The user interests 
 */ 
function rankCommentToInterests(comment, interests) { 
	var rank = 0; 
	var topics = createInterestList(interests.interest_topic); 	
	var locations = createInterestList(interests.interest_location); 	
	rank += countMatchesToInterests(comment.content, topics);
	rank += countMatchesToInterests(comment.content, locations);
	return rank; 
}

/* rankTagsToInterests 
 * Determines the relevance of a issue tags based on the frequency of matches to interests 
 * 
 * 'tagList' The issue's tag list 
 * 'interests' The user interests 
 *
 * TODO: Should finish implement when tag retrieval feature is finished 
 */ 
function rankTagsToInterests(tagList, interests) {
	var tags = tagList.join(' '); 
	countMatchesToInterests(tags, interests); 
}

/* buildRegExpQuery 
 * Creates a new regular expression which will search a string for matches to any of the defined search terms 
 * 
 * 'terms' An array of terms to search for 
 */ 
function buildRegExpQuery(terms) {
	var pattern = ''; 
	for (var i = 0; i < terms.length; i++) { 
		pattern += '\\b' + terms[i] + '\\b'; 
		if (i + 1 != terms.length) {
			pattern += '|' 
		}
	} 
	return new RegExp(pattern, 'ig');
}

/* createInterestList 
 * Builds an array from a string list of interests 
 * 
 * 'interests' A string list of interests (which are internally seperated by commas) 
 */ 
function createInterestList(interests) {
	var i = interests.replace(',', ' '); 
	return i.split(/\s+/); 
}
